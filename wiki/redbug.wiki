#summary simple interface to the tracing functionality

= redbug =

redbug aims to be a safe and simple interface to the erlang trace
functionality. The erlang tracing (the so-called "trace bifs",
`erlang:trace/3` and `erlang:trace_pattern/3`) are insanely
powerful. However, they might be a bit hard to get used to.

For example, imagine this problem;

We have a system using 10,000 processes. Due to a bug, someone
occasionally sends the atom `true` to an important server process. This
eventually causes total system failure. We can not easily load code
onto the system since it sits at a customer site.

Here's a piece of code (that can be pasted into the Erlang
shell). It will trigger when someone sends `true`, and log the name
and current function of the sending and the receiving processes.

{{{
% pulls out process info for a given pid. 
Pi = fun (P) -> 
 try 
  {element(2,case process_info(P,registered_name) of 
              [] -> process_info(P,initial_call); 
              R -> R 
             end), 
   element(2,process_info(P,current_function))} 
 catch _:_ -> dead 
 end 
end.

% called by Init. receives trace messages, filters, logs the hits.
Loop = fun (G) -> 
  receive {trace,Sender,send,true,Rec} -> io:fwrite("~p -> ~p~n", [Pi(Sender), Pi(Rec)]); 
  _ -> ok end, 
 G(G) 
end.
% called by spawn. registers, starts the trace, calls Loop
Init = fun () -> 
  register(trip,self()), 
  erlang:trace(all,true,[send]), 
  Loop(Loop) 
end.
}}}

We start the tracer;
{{{
1>spawn(Init).
}}}

For clarity, I'll register a name for the shell;
{{{
2>register(luke,self()).
true
}}}

So let's send ourself a 'true';
{{{
3> self()!true.
}}}

The tracer will print this;
{{{
{luke,{shell,eval_loop,3}} -> {luke,{shell,eval_loop,3}}
}}}

To be neat, I stop the tracer;
{{{
4>exit(whereis(trip),kill).
}}}

Powerful, but not terribly userfriendly.

So clearly, a higher-level interface is in order. The standard OTP
solution is called `dbg`. Alas, I must recommend against using this on
live systems, since it is way too easy to get it wrong. 

Try this for a laugh (it *will* kill the node). 
{{{5> dbg:tracer(),dbg:p(all,m).}}}

Another problem with `dbg` is that it does not lift the level of
abstraction enough.

= Details =

