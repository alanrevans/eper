#summary simple interface to the tracing functionality

= redbug =

redbug aims to be a safe and simple interface to the erlang trace
functionality. The erlang tracing (the so-called "trace bifs",
erlang:trace/3 and erlang:trace_pattern/3) are insanely
powerful. However, they might be a bit hard to get used to.

For example, imagine this problem;
  We have a system using 10,000 processes. Due to a bug, someone
occasionaly sends the atom 'true' to an important server process. This
eventually causes total system failure. We can not easily load code
onto the system since it sits at a customer site.
  Here's a piece of code (that can be pasted into the Erlang
shell). It will trigger when someone sends 'true', and log the name
and current function of the sending and the receiving processes.


{{{
% we want to define a spawnable fun; Init
Pi = fun (P) -> try {element(2,case process_info(P,registered_name) of [] -> process_info(P,initial_call); R -> R end), element(2,process_info(P,current_function))} catch _:_ -> dead end end.
Loop = fun (G) -> receive {trace,Sender,send,true,Rec} -> io:fwrite("~p -> ~p~n", [Pi(Sender), Pi(Rec)]); _ -> ok end, G(G) end.
Init = fun () -> register(trip,self()), erlang:trace(all,true,[send]), Loop(Loop) end.
}}}

% start
spawn(Init).

% stop
exit(whereis(trip),kill). 

= Details =
